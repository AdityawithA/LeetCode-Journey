We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].

You're given the startTime, endTime and profit arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.

If you choose a job that ends at time X you will be able to start another job that starts at time X.



import java.util.*;

class Solution {
    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {
        int n = startTime.length;

        // Step 1: Store jobs
        int[][] jobs = new int[n][3];
        for (int i = 0; i < n; i++) {
            jobs[i] = new int[]{startTime[i], endTime[i], profit[i]};
        }

        // Step 2: Sort by end time
        Arrays.sort(jobs, (a, b) -> Integer.compare(a[1], b[1]));

        // Step 3: DP array
        int[] dp = new int[n];
        dp[0] = jobs[0][2]; // first job profit

        for (int i = 1; i < n; i++) {
            // Profit including current job
            int includeProfit = jobs[i][2];
            int l = binarySearch(jobs, i); // last non-conflicting job index
            if (l != -1) {
                includeProfit += dp[l];
            }

            // Exclude or Include
            dp[i] = Math.max(dp[i - 1], includeProfit);
        }

        return dp[n - 1];
    }

    // Binary search: find last job ending <= current job's start
    private int binarySearch(int[][] jobs, int index) {
        int low = 0, high = index - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (jobs[mid][1] <= jobs[index][0]) {
                if (jobs[mid + 1][1] <= jobs[index][0]) {
                    low = mid + 1;
                } else {
                    return mid;
                }
            } else {
                high = mid - 1;
            }
        }
        return -1;
    }
}
